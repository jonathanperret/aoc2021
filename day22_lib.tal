~library/console.lib.tal
~library/string.tal
~library/math.tal

%STEP.on   {            }
%STEP.xmin { #0001 ADD2 }
%STEP.xmax { #0009 ADD2 }
%STEP.ymin { #0011 ADD2 }
%STEP.ymax { #0019 ADD2 }
%STEP.zmin { #0021 ADD2 }
%STEP.zmax { #0029 ADD2 }

%STEPSIZE { #0031 } %STEPPAD { $31 }
%MATSIZE { #3000 } %MATPAD { $3000 }

%TERMINATOR { #ff }

@step
  ( get-byte step* -- )
  &parse
    SWP2
    [ ;&get-byte-addr STA2 ]
    ( step* )

    ;&parse/get-byte JSR2 ,&not-eof JCN
      POP2
      #00
      RTN
      &not-eof

    DUP2 #01 ROT ROT STA
    ;&parse/get-byte JSR2 LIT 'n EQU ,&parse/on JCN
      DUP2 #00 ROT ROT STA
      ( eat second 'f' )
      ;&parse/get-byte JSR2 POP
    &parse/on

    ( step* )
    INC2

    ( eat space x = )
    ;&parse/get-byte JSR2 POP
    ;&parse/get-byte JSR2 POP
    ;&parse/get-byte JSR2 POP

    ( parse xmin )
    DUP2 ;&parse/number JSR2
    #0008 ADD2

    ( eat dot )
    ;&parse/get-byte JSR2 POP

    ( parse xmax )
    DUP2 ;&parse/number JSR2
    #0008 ADD2

    ( eat y = )
    ;&parse/get-byte JSR2 POP
    ;&parse/get-byte JSR2 POP

    ( parse ymin )
    DUP2 ;&parse/number JSR2
    #0008 ADD2

    ( eat dot )
    ;&parse/get-byte JSR2 POP

    ( parse ymax )
    DUP2 ;&parse/number JSR2
    #0008 ADD2

    ( eat z = )
    ;&parse/get-byte JSR2 POP
    ;&parse/get-byte JSR2 POP

    ( parse zmin )
    DUP2 ;&parse/number JSR2
    #0008 ADD2

    ( eat dot )
    ;&parse/get-byte JSR2 POP

    ( parse zmax )
    DUP2 ;&parse/number JSR2
    #0008 ADD2

    ( step* )
    POP2
    #01
    RTN

    ( -- b )
    &parse/get-byte
      LIT2 [ &get-byte-addr $2 ] JMP2

    ( step* -- )
    &parse/number
      #01 [ ;&parse/positive STA ]
      [ ;&parse/str ] ( step* s* )
      ;&parse/get-byte JSR2 STH ( step* s* : b )
      STH2k STArk POP2r INC2 ( step* s* : b )
      STHr LIT '- NEQ ,&parse/no-sign JCN
        #00 [ ;&parse/positive STA ]
        DEC2
      &parse/no-sign

      ( step* s* )
      &parse/next-digit
        ;&parse/get-byte JSR2 STH ( step* s* : b )
        STH2k STArk POP2r INC2 ( step* s* : b )
        STHr LIT '0 GEQ ,&parse/next-digit JCN

      ( step* s* )
      DEC2 #00 ROT ROT STA

      ( step* )
      DUP2 ;&parse/str ;parse64 JSR2

      [ ;&parse/positive LDA ] ,&parse/no-negate JCN
        DUP2 ;negate64 JSR2
      &parse/no-negate
      POP2

      RTN
      [ &parse/str $10 &parse/positive $1 ]


  ( step* -- )
  &dump
    DUP2 LDA DBGBYTEn SP POP
    DUP2 STEP.xmin ;print64/no-pad JSR2 SP
    DUP2 STEP.xmax ;print64/no-pad JSR2 SP
    DUP2 STEP.ymin ;print64/no-pad JSR2 SP
    DUP2 STEP.ymax ;print64/no-pad JSR2 SP
    DUP2 STEP.zmin ;print64/no-pad JSR2 SP
    DUP2 STEP.zmax ;print64/no-pad JSR2
    POP2
    LF
    RTN

@steps
  ( get-byte -- )
  &parse
    [ ;&parse/get-byte STA2 ]

    ;&steps ( steps* )
    &parse/more
      LIT2 [ &parse/get-byte $2 ] OVR2 ;step/parse JSR2 STH
      STEPSIZE ADD2
      STHr ,&parse/more JCN

    ( terminate list )
    STEPSIZE SUB2
    TERMINATOR ROT ROT STA
    RTN

  ( -- )
  &dump
    ;&dump/one ;&foreach JMP2

    ( step* -- )
    &dump/one
      ;step/dump JMP2

  ( [ step* -- ] -- )
  &foreach
    [ ;&foreach/fn STA2 ]
    ;&steps ( steps* )
    &foreach/loop
      LDAk TERMINATOR EQU ,&foreach/done JCN
      ( steps* )
      DUP2 LIT2 [ &foreach/fn $2 ] JSR2
      STEPSIZE ADD2
      ,&foreach/loop JMP
    &foreach/done
    ( steps* )
    POP2
    RTN

  [ &steps $6000 ]

  ( xmin* xmax* ymin* ymax* z* -- )
  &draw
    [ ;&draw/z* STA2 ]
    [ ;&draw/ymax* STA2 ]
    [ ;&draw/ymin* STA2 ]
    [ ;&draw/xmax* STA2 ]
    [ ;&draw/xmin* STA2 ]
    ;&draw/one ;&foreach JSR2
    RTN
    [ &draw/z* $8 &draw/xmin* $8 &draw/xmax* $8 &draw/ymin* $8 &draw/ymax* $8 ]

    ( step* -- )
    &draw/one
      [ ;&draw/step* STA2 ]

      [ ;&draw/z* LDA2 ] [ [ ;&draw/step* LDA2 ] STEP.zmin ] ;greaterthan64 JSR2 NOT ;&draw/z-out JCN2
      [ [ ;&draw/step* LDA2 ] STEP.zmax ] [ ;&draw/z* LDA2 ] ;greaterthan64 JSR2 NOT ;&draw/z-out JCN2

      ;&draw/ystart [ ;&draw/step* LDA2 ] STEP.ymin ] [ ;&draw/ymin* LDA2 ] ;sub64 JSR2
      ;&draw/yend [ ;&draw/step* LDA2 ] STEP.ymax ] [ ;&draw/ymin* LDA2 ] ;sub64 JSR2

      ;&draw/xstart [ ;&draw/step* LDA2 ] STEP.xmin ] [ ;&draw/xmin* LDA2 ] ;sub64 JSR2
      ;&draw/xend [ ;&draw/step* LDA2 ] STEP.xmax ] [ ;&draw/xmin* LDA2 ] ;sub64 JSR2

      [ [ ;&draw/step* LDA2 ] STEP.on LDA ] [ ;&draw/byte STA ]

      [ ;&draw/ystart LDA2 SWP ] ( ystart )
      [ ;&draw/yend LDA2 SWP ] INC2 ( yend )
      DO
        [ ;&draw/xstart LDA2 SWP ] ( xstart )
        [ ;&draw/xend LDA2 SWP ] INC2 ( xend )
        DO
          ( y x )
          OVR2 STH2 STH2k ( y x : x y )
          LIT [ &draw/byte $1 ] STH2r STH2r ;matrix/set-at JSR2
        LOOP
      LOOP
      RTN

      &draw/z-out
        ( step* )
        RTN

      [ &draw/step* $2
        &draw/xstart $8 &draw/xend $8
        &draw/ystart $8 &draw/yend $8
      ]

@matrix
  ( w h -- )
  &init
    [ ;&h STA2 ]
    [ ;&w STA2 ]
    #00 MATSIZE ;&mat ;memset JSR2
    RTN

  ( x y -- )
  &get-at
    [ ;&w LDA2 ] MUL2 ADD2
    ;&mat ADD2 LDA
    RTN

  ( b x y -- )
  &set-at
    DUP2 [ ;&h LDA2 ] GEQ2 ,&set-at/outside JCN
    OVR2 [ ;&w LDA2 ] GEQ2 ,&set-at/outside JCN

    [ ;&w LDA2 ] MUL2 ADD2
    ;&mat ADD2 STA
    RTN

    &set-at/outside
    POP2 POP2 POP RTN

  ( -- )
  &dump
    #0000 [ ;&h LDA2 ] DO
      ( draw flipped on y )
      [ ;&h LDA2 ] DEC2 OVR2 SUB2
      #0000 [ ;&w LDA2 ] DO
        DUP4 SWP2 ;&get-at JSR2 STH
        LIT '#
        STHr ,&dump/set JCN
          POP LIT '.
          &dump/set
        EMIT
      LOOP
      LF
      POP2
    LOOP
    RTN

  ( -- cnt )
  &count
    #0000 [ ;&total STA2 ]
    #0000 [ ;&h LDA2 ] DO
      #0000 [ ;&w LDA2 ] DO
        DUP4 SWP2 ;&get-at JSR2
        #00 SWP [ ;&total LDA2 ] ADD2 [ ;&total STA2 ]
      LOOP
    LOOP
    [ ;&total LDA2 ]
    RTN
    [ &total $2 ]

  [ &mat MATPAD &w $2 &h $2 ]
