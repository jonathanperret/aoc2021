~library/console.lib.tal
~library/string.tal
~library/math.tal

%STATEPAD { $5 } %STATESIZE { #0005 }
%STATE.pos1   {            }
%STATE.pos2   { #0001 ADD2 }
%STATE.score1 { #0002 ADD2 }
%STATE.score2 { #0003 ADD2 }
%STATE.nextup { #0004 ADD2 }

%STATELISTPAD { $1000 } %STATELISTSIZE { #1000 }

%SLENTRYPAD { $d } %SLENTRYSIZE { #000d }

%STATEBUFPAD { $4000 } %STATEBUFSIZE { #4000 }

%POSCOUNT { #04 }
%WINSCORE { #0005 }

%COUNTSIZE { #0008 } %COUNTPAD { $8 }

%TERMINATOR { #ffff }

@state
  ( st* player1pos player2pos player1score player2score nextup -- )
  &init
    STH STH STH STH STH
         STH2k STAr
    INC2 STH2k STAr
    INC2 STH2k STAr
    INC2 STH2k STAr
    INC2 STH2  STAr
    RTN

  ( st* -- )
  &print
  &dump
    LIT '[ EMIT
         LDAk DBGBYTEDECn SP POP
    INC2 LDAk DBGBYTEDECn SP POP
    INC2 LDAk DBGBYTEDECn SP POP
    INC2 LDAk DBGBYTEDECn SP POP
    INC2 LDA  DBGBYTEDECn    POP
    LIT '] EMIT
    RTN

  ( stout* stin* -- )
  &copy
    SWP2
    STATESIZE ;memcpy JSR2 ( stout* : dicesum )
    RTN

  ( st1* st2* -- equal )
  &equal
    STH2 ( st1* : st2* )
    LDAk LDArk STHr NEQ ,&equal/not JCN
    INC2 INC2r
    LDAk LDArk STHr NEQ ,&equal/not JCN
    INC2 INC2r
    LDAk LDArk STHr NEQ ,&equal/not JCN
    INC2 INC2r
    LDAk LDArk STHr NEQ ,&equal/not JCN
    INC2 INC2r
    LDA  LDAr  STHr NEQ ,&equal/not JCN
    #01 RTN
    &equal/not
    POP2 POP2r
    #00 RTN

  ( stout* stin* dicesum -- )
  &advance
    STH
    ( stout* stin* : dicesum )
    OVR2 SWP2 ( stout* stout* stin* : dicesum )
    ;&copy JSR2 ( stout* : dicesum )

    [ DUP2 STATE.nextup LDA ] [ #00 SWP ;&advance/offset STA2 ]
    ( stout* : dicesum )
    DUP2 STATE.pos1 [ ;&advance/offset LDA2 ] ADD2 ( stout* pos* : dicesum )
    LDAk STHr ADD ( stout* pos* pos+dicesum )
    DEC #0a MOD INC ( stout* pos* (pos+dicesum)-1)%10+1 )
    STHk ROT ROT STA ( stout* : newpos )

    DUP2 STATE.score1 [ ;&advance/offset LDA2 ] ADD2 ( stout* score* : newpos )
    LDAk STHr ADD ( stout* score* newscore )
    DUP #14 GTH ,&advance/win JCN
    ( stout* score* newscore )
    ROT ROT STA ( stout* )
    ( toggle nextup )
    STATE.nextup ( nextup* )
    LDAk #01 EOR ROT ROT STA
    RTN

    &advance/win
    ( stout* score* newscore )
    POP
    ( store 21 as score )
    #15 ROT ROT STA
    ( stout * )
    ( store 0 as other score )
    DUP2 [ DUP2 STATE.nextup LDA ] #01 EOR #00 SWP ADD2 STATE.score1 #00 ROT ROT STA
    ( store 0 as positions )
    STATE.pos1 #0000 SWP2 STA2

    RTN
    [ &advance/offset $2 ]

@statelist
  ( sl* -- )
  &init
    POP2 ;statebuf/init JMP2

  ( sl* -- )
  &dump
    POP2 ;statebuf/dump JMP2

  ( sl* -- count )
  &count
    POP2 ;statebuf/count JMP2

  ( sl* [ sl* -- ] -- )
  &foreach
    NIP2 ;statebuf/foreach JMP2

  ( sl* st* count* -- )
  &add
    ROT2 POP2 ;statebuf/add JMP2

@universes
  ( pos1 pos2 -- )
  &init
    ;end-of-all-things DBGSHORT POP2
    STH STH
    ;&st STHr STHr #00 #00 #00 ;state/init JSR2
    ;&slist1 ;statelist/init JSR2
    ;&stcount #0001 ;short-to-64 JSR2
    ;&slist1 ;&st ;&stcount ;statelist/add JSR2
    RTN

  ( -- )
  &dump
    ;&slist1 ;statelist/dump JMP2

  ( -- count )
  &count
    ;&slist1 ;statelist/count JMP2

  ( -- )
  &advance
    ;&slist2 ;statelist/init JSR2
    ;&slist1 ;&advance/from ;statelist/foreach JSR2
    ;&slist2 ;&slist1 STATELISTSIZE ;memcpy JSR2
    RTN

    ( slentry* -- )
    &advance/from
      [ ;&advance/entry STA2 ]
      #0003 #000a DO
        STHk ;&st [ ;&advance/entry LDA2 ] STHr ;state/advance JSR2

        ;&stcount [ [ ;&advance/entry LDA2 ] STATESIZE ADD2 ] ;copy64 JSR2

        ;&slist2 ;&st ;&stcount ;statelist/add JSR2
      LOOP

      RTN
      [ &advance/entry $2 ]

  [ &st STATEPAD &stcount COUNTPAD
    &slist1 STATELISTPAD &slist1-end
    &slist2 STATELISTPAD
    ]

@statebuf
  &init
    #00 STATEBUFSIZE ;&buf ;memset JSR2
    RTN

  ( st* count* -- )
  &add
    STH2
    ( st* : count* )

    DUP2 ;&addr JSR2

    ( st* pagenum offset : count* )

    DUP4 ;&add/count ROT2 ROT2 ;&load JSR2

    ( st* pagenum offset : count* )
    ;&add/count STH2r ;add64 JSR2

    ( st* pagenum offset )
    ;&add/count ROT2 ROT2 ;&store JSR2

    ( st* )
    POP2
    RTN
    [ &add/count COUNTPAD ]

  %PAGESIZE { WINSCORE WINSCORE COUNTSIZE MUL2 MUL2 }

  ( pagenum offset -- ptr )
  &ptr
    STH2 PAGESIZE MUL2 STH2r ADD2
    ( DBGSHORTn SP P< "bytes 20 "into 20 "buffer >P LF )
    DUP2 STATEBUFSIZE LTH2 ,&ptr/ptr-ok JCN
      P< "buffer_overflow >P SP DBGSHORT LF
      !
      &ptr/ptr-ok
    ;&buf ADD2 ( count* ptr* )
    RTN

  ( count* pagenum offset )
  &store
    ( P< "store >P SP OVR2 DBGSHORTn SP POP2 DBGSHORT )
    ;&ptr JSR2
    ( count* ptr* )
    ( OVR2 ;print64/no-pad JSR2 LF )
    SWP2 ;copy64 JSR2
    RTN

   [ &buf STATEBUFPAD &buf-end ]

  ( count* pagenum offset )
  &load
    ( P< "load >P SP OVR2 DBGSHORTn SP POP2 DBGSHORT )
    ;&ptr JSR2
    ( count* ptr* )
    ;copy64 JSR2
    RTN

  ( -- )
  &dump
    #0000 [ ;&dump/entrycount STA2 ]
    ;&dump/one ;&foreach JSR2
    [ ;&dump/entrycount LDA2 ] DBGSHORTDECn POP2
    RTN

    [ &dump/entrycount $2 ]

    ( st* count* -- )
    &dump/one
      SWP2 ;state/print JSR2
      LIT ': EMIT
      ;print64/no-pad JSR2
      [ ;&dump/entrycount *INC2 ]
      SP
      RTN

  ( st* -- pagenum offset )
  &addr
    DUP2 [ STATE.score1 LDA ] #00 SWP WINSCORE MUL2 STH2
    DUP2 [ STATE.score2 LDA ] #00 SWP STH2 ADD2r
    COUNTSIZE STH2 MUL2r
    ( st* : offset )

    LITr 00
    DUP2 [ STATE.nextup LDA ] [ POSCOUNT POSCOUNT MUL ] MUL STH
    DUP2 [ STATE.pos1 LDA ] DEC POSCOUNT MUL STH ADDr
    DUP2 [ STATE.pos2 LDA ] DEC STH ADDr
    ( st* : pagenum offset )

    POP2 STH2r STH2r
    ( pagenum offset )
    RTN

  ( [ st* count* -- ] -- )
  &foreach
    [ ;&foreach/fn STA2 ]
    #0000 #0002 DO
      ( nextup )
      DUP [ ;&foreach/st STATE.nextup STA ]
      #0000 #00 POSCOUNT DO
        ( pos1-1 )
        DUP INC [ ;&foreach/st STATE.pos1 STA ]
        #0000 #00 POSCOUNT DO
          ( pos1-1 pos2-1 )
          DUP INC [ ;&foreach/st STATE.pos2 STA ]

          OVR2 #00 POSCOUNT MUL2 OVR2 ADD2
          [ ;&foreach/st STATE.nextup LDA ] [ POSCOUNT POSCOUNT MUL ] MUL #00 SWP ADD2

          ( pos1-1 pos2-1 pagenum )

          #0000 WINSCORE DO
            ( pos1-1 pos2-1 pagenum score1 )
            DUP [ ;&foreach/st STATE.score1 STA ]
            #0000 WINSCORE DO
              ( pos1-1 pos2-1 pagenum score1 score2 )
              DUP [ ;&foreach/st STATE.score2 STA ]

              ( pos1-1 pos2-1 pagenum score1 score2 )

              ;&foreach/st ;&addr JSR2

              ( pos1-1 pos2-1 pagenum score1 score2 pagenum offset )

              ;&foreach/count ROT2 ROT2 ;&load JSR2

              ( pos1-1 pos2-1 pagenum score1 score2 )

              ;&foreach/count ;is-non-zero64 JSR2 NOT ,&foreach/zero JCN
                ;&foreach/st ;&foreach/count LIT2 [ &foreach/fn $2 ] JSR2
              &foreach/zero

              ( pos1-1 pos2-1 pagenum score1 score2 )
            LOOP
          LOOP

          POP2

        LOOP
      LOOP
    LOOP

    RTN
    [ &foreach/count COUNTPAD &foreach/st STATEPAD ]

  ( -- count )
  &count
    #0000 [ ;&count/count STA2 ]
    ;&count/one ;&foreach JSR2
    [ ;&count/count LDA2 ]
    RTN

    [ &count/count $2 ]

    ( st* count* -- )
    &count/one
      POP2 POP2
      [ ;&count/count *INC2 ]
      RTN

@end-of-all-things 00

