~library/console.lib.tal
~library/string.tal
~library/math.tal
~day19_rotations.tal

%TERMINATOR { #8080 }

%V3SIZE { #0006 } %V3PAD { $6 }

@scanner
  ( get-byte sc* -- count )
  &parse
    [ ;&parse/sc STA2 ]
    [ ;&parse/get-byte-addr STA2 ]

    [ ;&parse/sc LDA2 ] ;&init JSR2

    ;&parse/skip-line JSR2 ,&parse/header-ok JCN
      ( eof while reading header )
      #00
      RTN
    &parse/header-ok

    #00 [ ;&parse/count STA ]

    &parse/line-loop
      ;&parse/number JSR2 NOT ;&parse/done JCN2
      [ ;&parse/count *INC ]

      ;&parse/number JSR2 POP
      ;&parse/number JSR2 POP

      ( x y z )
      ;&parse/insert JSR2

      ;&parse/line-loop JMP2

    &parse/done
    ( 0000 )
    POP2

    [ ;&parse/count LDA ]
    RTN
    [ &parse/sc $2 &parse/count $1 ]

    ( -- b )
    &parse/get-byte
      LIT2 [ &parse/get-byte-addr $2 ] JMP2

    ( -- success )
    &parse/skip-line
      &parse/skip-line/loop
        ;&parse/get-byte JSR2
        DUP #00 EQU ,&parse/skip-line/eof JCN
        #0a NEQ ,&parse/skip-line/loop JCN
      #01
      RTN
      &parse/skip-line/eof
      ( 00 )
      POP #00
      RTN

    ( -- n success )
    &parse/number
      LIT2r 0000 ( : n )
      #00 [ ;&parse/number/started STA ]
      #0001 [ ;&parse/number/sign STA2 ]
      &parse/number/loop
        ;&parse/get-byte JSR2
        DUP LIT '- LTH ,&parse/number/done JCN
        DUP LIT '- NEQ ,&parse/number/positive JCN
          #ffff [ ;&parse/number/sign STA2 ]
          POP
          ,&parse/number/loop JMP
          &parse/number/positive
        LIT '0 SUB #00 SWP ( value : n )
        STH2r #000a MUL2 ADD2 STH2 ( : n*10+value )
        #01 [ ;&parse/number/started STA ]
        ,&parse/number/loop JMP
      &parse/number/done
      ( terminator )
      POP
      STH2r
      [ ;&parse/number/sign LDA2 ] MUL2
      [ ;&parse/number/started LDA ]
      RTN
      [ &parse/number/sign $2 &parse/number/started $1 ]

    ( x y z -- )
    &parse/insert
      ;&parse/v #0004 ADD2 STA2
      ;&parse/v #0002 ADD2 STA2
      ;&parse/v            STA2
      [ ;&parse/sc LDA2 ] ;&parse/v ;&insert JSR2
      RTN
      [ &parse/v V3PAD ]

  ( sc* -- )
  &dump
    ( sc* )
    &dump/loop
      LDA2k TERMINATOR EQU2 ,&dump/done JCN
      DUP2 ;vector3/print JSR2 LF
      V3SIZE ADD2
      ,&dump/loop JMP
    &dump/done
    POP2
    RTN

  ( sc* v* -- )
  &insert
    ( P< "inserting 20 >P DUP2 ;vector3/print JSR2 LF )
    ( sc* v* )
    ;&insert/v SWP2 ;vector3/copy JSR2

    ( find insertion point )
    ( sc* )
    &insert/scan-loop
      LDA2k TERMINATOR EQU2 ,&insert/scan-done JCN
      ;&insert/v OVR2 ;vector3/equal JSR2
      ( if v == *sc, abort )
      ,&insert/done JCN

      ;&insert/v OVR2 ;vector3/less-than JSR2
      ( if v < *sc, we've found our spot )
      ,&insert/scan-done JCN
      ( otherwise advance )
      V3SIZE ADD2
      ,&insert/scan-loop JMP

    &insert/scan-done

    ( make some room )
    DUP2 ;&insert/shift-right JSR2

    ( insert at spot found )
    DUP2 ;&insert/v ;vector3/copy JSR2

    &insert/done
    POP2
    RTN

    [ &insert/v V3PAD &insert/vtmp V3PAD ]

    ( sc* -- )
    &insert/shift-right
      ( scan to end )
      DUP2
      ( sc* sc-end* )
      &insert/shift-right/scan-loop
        LDA2k ( sc* sc-end* word )
        TERMINATOR EQU2 ,&insert/shift-right/at-end JCN
        V3SIZE ADD2
        ,&insert/shift-right/scan-loop JMP

      &insert/shift-right/at-end
      ( sc* sc-end* )
      ( grow list here )
      #0000 OVR2 STA2
      V3SIZE ADD2
      TERMINATOR OVR2 STA2

      ( now copy backwards until sc-end = sc )
      SWP2 STH2
      ( sc-end* : sc* )
      &insert/shift-right/copy-loop
        V3SIZE SUB2
        EQU2k ,&insert/shift-right/copy-done JCN
        ( copy left into right )
        DUP2 DUP2 V3SIZE SUB2
        ( sc-end* sc-end* sc-end-V3SIZE* )
        ;vector3/copy JSR2
        ,&insert/shift-right/copy-loop JMP

      &insert/shift-right/copy-done
      ( sc-end* : sc* )
      POP2r
      POP2
      RTN

  ( scout* scin* rotation -- )
  &rotate
    ;rotations/get JSR2
    ( scout* scin* rotate )
    ;&map JMP2

  ( scout* scin* v* -- )
  &translate
    [ ;&translate/v STA2 ]
    ;&translate/addv
    ( scout* scin* addv )
    ;&map JMP2
    ( vout* vin* -- )
    &translate/addv
      LIT2 [ &translate/v $2 ] ;vector3/add JMP2

  ( sc* -- )
  &init
    TERMINATOR SWP2 STA2
    RTN

  ( scout* scin* [ vout* vin* -- ] -- )
  &map
    [ ;&map/fn STA2 ]

    ( initialize output list )
    OVR2 ;&init JSR2

    SWP2 STH2
    ( scin* : scout* )
    &map/loop
      LDA2k TERMINATOR EQU2 ,&map/done JCN
      ;&map/vout OVR2 LIT2 [ &map/fn $2 ] JSR2
      STH2rk ;&map/vout ;&insert JSR2
      ( scin* : scout* )
      V3SIZE ADD2
      ,&map/loop JMP
    &map/done
    ( scin* : scout* )
    POP2 POP2r
    RTN
    [ &map/vout V3PAD ]

  ( sc1* sc2* -- count )
  &count-matches
    ( Both lists are sorted, this should be easy:
      - while i<len(A) and j<len(B):
        - if A[i] == B[j], increase match count, increase i, increase j;
        - otherwise if A[i] < B[j], increase i;
        - otherwise, increase j. )
    STH2
    ( sc1* : sc2* )

    #0000 [ ;&count-matches/count STA2 ]

    &count-matches/loop
      ( break if any list has reached its end )
      LDA2k TERMINATOR EQU2 ,&count-matches/done JCN
      STH2rk LDA2 TERMINATOR EQU2 ,&count-matches/done JCN
      ( sc1* : sc2* )
      DUP2 STH2rk ;vector3/equal JSR2 ,&count-matches/v1==v2 JCN

      ( sc1* : sc2* )
      DUP2 STH2rk ;vector3/less-than JSR2 ,&count-matches/v1<v2 JCN
        ( v1>v2: advance sc2* )
        STH2r V3SIZE ADD2 STH2 ( advance sc2* )
        ,&count-matches/loop JMP

      &count-matches/v1<v2
        ( v1<v2: advance sc1* )
        V3SIZE ADD2
        ,&count-matches/loop JMP

      &count-matches/v1==v2
        ( v1 == v2: increase count, advance both )
        [ ;&count-matches/count *INC2 ]
        V3SIZE ADD2            ( advance sc1* )
        STH2r V3SIZE ADD2 STH2 ( advance sc2* )
        ,&count-matches/loop JMP

    &count-matches/done

    ( sc1* : sc2* )
    POP2 POP2r
    [ ;&count-matches/count LDA2 ]
    RTN
    [ &count-matches/count $2 ]

  ( sc* -- count )
  &count
    LIT2r 0000 ( sc* : count )
    &count/loop
      LDA2k TERMINATOR EQU2 ,&count/done JCN
      INC2r
      V3SIZE ADD2
      ,&count/loop JMP
    &count/done
    POP2 STH2r
    RTN

  ( finds a vector that moves sc2 over to sc1 )
  ( sc1* sc2* target -- success )
  &find-alignment
    [ ;&fa/target STA2 ]
    ( generate all pairs )
    [ ;&fa/sc2 STA2 ]
    [ ;&fa/sc1 STA2 ]
    [ ;&fa/sc1 LDA2 ] ;&count JSR2 [ ;&fa/sc1count STA2 ]
    [ ;&fa/sc2 LDA2 ] ;&count JSR2 [ ;&fa/sc2count STA2 ]
    #0000 [ ;&fa/sc1count LDA2 ] DO
      #0000 [ ;&fa/sc2count LDA2 ] DO
        OVR2 POP2
        ( make offset vector that potentially brings sc2 into alignment with sc1: v1-v2 )
        OVR2 V3SIZE MUL2 [ ;&fa/sc1 LDA2 ] ADD2 [ ;&fa/v1 STA2 ]
        DUP2 V3SIZE MUL2 [ ;&fa/sc2 LDA2 ] ADD2 [ ;&fa/v2 STA2 ]
        ;&find-alignment/offset [ ;&fa/v1 LDA2 ] [ ;&fa/v2 LDA2 ] ;vector3/subtract JSR2

        ;&fa/sc2moved [ ;&fa/sc2 LDA2 ] ;&find-alignment/offset ;&translate JSR2

        [ ;&fa/sc1 LDA2 ] ;&fa/sc2moved ;&count-matches JSR2
        ( match-count )
        [ ;&fa/target LDA2 ] LTH2 ,&fa/not-found JCN
          UNLOOP
          UNLOOP
          #01
          RTN
          &fa/not-found
      LOOP
    LOOP
    #00
    RTN
    [ &find-alignment/offset V3PAD
      &fa/target $2
      &fa/sc1 $2
      &fa/sc2 $2
      &fa/v1 $2
      &fa/v2 $2
      &fa/sc1count $2
      &fa/sc2count $2
      &fa/sc2moved $100 ]

@vector3
  ( v* -- )
  &print
    LIT '[ EMIT
    LDA2k ;print-short-decimal/signed JSR2 #0002 ADD2 SP
    LDA2k ;print-short-decimal/signed JSR2 #0002 ADD2 SP
    LDA2  ;print-short-decimal/signed JSR2
    LIT '] EMIT
    RTN

  ( vdest* vsrc* -- )
  &copy
    SWP2 V3SIZE ;memcpy JMP2

  ( vdest* v1* v2* -- )
  &add
    STH2 ( vdest* v1* : v2* )
    OVR2 SWP2 ;&copy JSR2 ( vdest*=v1 : v2* )
    LDA2k STH2rk LDA2 ADD2 OVR2 STA2 2++ 2++r
    LDA2k STH2rk LDA2 ADD2 OVR2 STA2 2++ 2++r
    LDA2k STH2r  LDA2 ADD2 SWP2 STA2
    RTN

  ( vdest* v1* v2* -- )
  &subtract
    STH2 ( vdest* v1* : v2* )
    OVR2 SWP2 ;&copy JSR2 ( vdest*=v1 : v2* )
    LDA2k STH2rk LDA2 SUB2 OVR2 STA2 2++ 2++r
    LDA2k STH2rk LDA2 SUB2 OVR2 STA2 2++ 2++r
    LDA2k STH2r  LDA2 SUB2 SWP2 STA2
    RTN

  ( v1* v2* -- v1==v2 )
  &equal
    STH2 ( v1* : v2* )

    LDA2k STH2rk LDA2
    NEQ2 ,&equal/not-equal JCN
    2++ 2++r

    LDA2k STH2rk LDA2
    NEQ2 ,&equal/not-equal JCN
    2++ 2++r

    LDA2k STH2rk LDA2
    NEQ2 ,&equal/not-equal JCN
    2++ 2++r

    POP2 POP2r
    #01 RTN

    &equal/not-equal
      POP2 POP2r
      #00 RTN

  ( v1* v2* -- v1<v2 )
  &less-than
    STH2 ( v1* : v2* )
    LDA2k STH2rk LDA2
    ( v1* v1.x v2.x : v2* )
    SGTH2k ,&less-than/not-lesser JCN
      ( v1* v1.x v2.x : v2* )
      EQU2 NOT ,&less-than/lesser JCN
      ( v1.x == v2.x )

    2++ 2++r ( v1+2* : v2+2* )

    LDA2k STH2rk LDA2
    ( v1* v1.y v2.y : v2* )
    SGTH2k ,&less-than/not-lesser JCN
      ( v1* v1.y v2.y : v2* )
      EQU2 NOT ,&less-than/lesser JCN
      ( v1.y == v2.y )

    2++ 2++r ( v1+4* : v2+4* )

    LDA2k STH2rk LDA2
    ( v1* v1.z v2.z : v2* )
    SGTH2k ,&less-than/not-lesser JCN
      ( v1* v1.z v2.z : v2* )
      EQU2 NOT ,&less-than/lesser JCN
      ( v1.z == v2.z )
      POP2 POP2r #00 RTN

    &less-than/not-lesser
    ( v1* v1.? v2.? : v2* )
    POP2 POP2 POP2 POP2r #00 RTN

    &less-than/lesser
    ( v1* : v2* )
    POP2 POP2r #01 RTN


@scanners
  ( get-byte -- )
  &parse
    #0000 [ ;&count STA2 ]
    LIT2r :&scannersbuf
    ( get-byte : scannersbuf* )
    &parse/loop
      DUP2 STH2rk ;scanner/parse JSR2
      ( count )
      DUP NOT ;&parse/done JCN2
      ( count )

      ( store current pointer in scanners array )
      STH2rk ;&scanners [ ;&count LDA2 ] 2** ADD2 STA2

      ( count )

      ( bump pointer by scanner size )
      #00 SWP V3SIZE MUL2 2++ STH2r ADD2 STH2 ( : scannersbuf+6*count* )

      [ ;&count *INC2 ]
      ;&parse/loop JMP2

    &parse/done
    ( get-byte count : scannersbuf* )
    POP POP2 POP2r
    RTN

  ( -- )
  &dump
    [ ;&count LDA2 ] #0000 NEQ2 ,&dump/not-zero JCN
      RTN
    &dump/not-zero
    #0000 [ ;&count LDA2 ] DO
      DUP2 ;print-short-decimal JSR2 LIT ': EMIT LF
      DUP2 2** ;&scanners ADD2 LDA2 ;scanner/dump JSR2
    LOOP
    RTN

  [ &count $2 &scannersbuf $2000 &scanners $40 ]
