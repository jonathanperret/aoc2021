# Part 1

Segment count

  1 : 2
  2 : 5
  3 : 5
  4 : 4
  5 : 5
  6 : 6
  7 : 3
  8 : 7
  9 : 6

Indeed, 1, 4, 7 and 8 are the unambiguous ones, using respectively
2, 4, 3 and 7 segments.

A minimal strategy for this part could be to:

   - repeat:
     - scan each line for '|';
     - count the number of non-whitespace characters;
     - increment counter;
     - if last whitespace was a newline, loop.

# Part 2

The easy digits in part 1 might be a misdirection.
Wouldn't it be easier to brute-force the segment assignments?

Let's see, we have 7 segments so we're looking for a 7-element
permutation. There are 7! of those, which comes out to 5880.

Would it work to try up to 5880 interpretations of each line?
We only have 200 lines to process, so that doesn't sound too bad.

Note that we only need to scan up to the '|' to find the right
assignment.

First, let's change the part 1 code to scan to the left of '|'
instead of the right.

Then, we will need to be able to scan the same line multiple times.
Or, we could extract the digits to an array on an initial scan,
then repeatedly check various permutations.

Let's try splitting the digits, argv-style.

Now, how can we represent a wire mapping?
A string like "abcdefg" or "gfedcba" looks fine.

Given a digit e.g. "abg" and a mapping "abdcfeg", how do we
check that it maps to a well-formed digit?

We can first convert the digit to binary number:
  - init a byte to zero;
  - go through digit, set bit number "byte - 'a'"

So "abg" -> 110 0001 -> 0x61. Note that we can do this processing
for all digits before looking for the correct mapping.

Then, if we have a digit represented as a 7-bit byte as above (called
'inbyte' below), pand a mapping given as "abdcfeg", we can remap the byte:
  - init outbyte to 0;
  - init outbitpos to 0;
  - for each mapping char:
    - set inbitpos to (mapping char) - 'a';
    - set outbyte[outbitpos] to inbyte[inbitpos];
    - increase outbitpos.

The exact meaning assigned by this algorithm to a mapping such as "abdcfeg"
is a bit difficult to ascertain, but I'm reasonably confident it will map
all bits and that every permutation of "abcdefg" will yield a different
mapping.

Once we have transformed the digit's byte, e.g. from 1100001 to 0001110,
we can look that value up in a list of valid digits, which can be manually
constructed:

  0:      1:      2:      3:      4:      5:      6:      7:      8:      9:
 aaaa    ....    aaaa    aaaa    ....    aaaa    aaaa    aaaa    aaaa    aaaa
b    c  .    c  .    c  .    c  b    c  b    .  b    .  .    c  b    c  b    c
b    c  .    c  .    c  .    c  b    c  b    .  b    .  .    c  b    c  b    c
 ....    ....    dddd    dddd    dddd    dddd    dddd    ....    dddd    dddd
e    f  .    f  e    .  .    f  .    f  .    f  e    f  .    f  e    f  .    f
e    f  .    f  e    .  .    f  .    f  .    f  e    f  .    f  e    f  .    f
 gggg    ....    gggg    gggg    ....    gggg    gggg    ....    gggg    gggg

1110111 0010010 1011101 1011011 0111010 1101011 1101111 1010010 1111111 1111011

If I got those right, these are the "correct" bytes:

  0x77 0x12 0x5d 0x5b 0x3a 0x6b 0x6f 0x52 0x7f 0x7b

What bricks do we still need then?
  - digit-to-byte ( digit* -- byte )
    - init byte to 0;
    - for each char in digit:
        set bit (char - 'a') in byte;
    - return byte.

  - apply-mapping-to-byte ( mapping* inbyte -- outbyte )
    - init outbyte to 0;
    - init outbitpos to 0;
    - for each mapping char:
      - set inbitpos to (mapping char) - 'a';
      - set outbyte[outbitpos] to inbyte[inbitpos];
      - increase outbitpos;
    - return outbyte.

  - lookup-digit-byte ( byte -- value-or-ff )
    - if byte == 0x77 return 0
    - if byte == 0x12 return 1
    - …
    - return 0xff

  - check-digit-byte ( byte -- ok )
    - call lookup-digit-byte;
    - if result is 0xff, return 0;
    - return 1;

  - digits-to-bytes ( digit-array** bytes* -- )
    - for each digit in digit-array:
      - call digit-to-byte;
      - append byte to bytes.

  - apply-mapping-to-bytes ( mapping* inbytes* outbytes* -- )
    - for each byte in inbytes:
      - call apply-mapping-to-byte;
      - append result to outbytes.

  - check-digit-bytes ( bytes* -- )
    - for each byte in bytes:
      - call check-digit-byte;
      - if result is 0, return 0;
    - return 1.

  - enumerate-mappings ( visitor* -- ) where visitor ( mapping* -- continue )

        …

  - digit-bytes-to-decimal ( bytes* -- num )
    - init result to 0;
    - for each byte in bytes:
      - multiply number by 10;
      - call lookup-digit-byte;
      - add result to number;
    - return number.

  - process-line ( get-byte -- num )
    - call split-digits;
    - call digits-to-bytes;
    - call enumerate-mappings with this visitor:
      - call apply-mapping-to-bytes;
      - call check-digit-bytes;
    - call split-digits; (parsing the right side)
    - call digits-to-bytes;
    - call apply-mapping-to-bytes;
    - call digit-bytes-to-decimal.



