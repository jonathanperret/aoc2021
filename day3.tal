~library/macros.tal

( devices )

|00 @System     [ &vector $2 &wst  $1 &rst    $1 &pad   $4 &r $2 &g $2 &b $2   &debug $1 &halt $1 ]
|10 @Console    [ &vector $2 &read $1 &pad    $5 &write $1 &error  $1 ]
|a0 @File       [ &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2 ]

( variables )

|0000
@counts  $32
@i           $1
@n           $2
@bit-count   $1
@line-count  $2
@half-count  $2
@gamma       $2
@epsilon     $2
@gamma64     $8
@epsilon64   $8
@result64    $8

( init )

|0100 @program
  ;on-arg-char .Console/vector DEO2
  BRK !

@on-arg-char
  .Console/read DEI ( char )
  DUP #0a EQU ,&complete JCN
  ;&arg-line #00 ,&fnptr LDR ADD2 STA
  ,&fnptr LDR INC ,&fnptr STR
  BRK !

  &complete
  POP
  ;&arg-line ;arg-received JMP2

  &fnptr $1
  &arg-line $64

( filename* -- )
@arg-received
  LIT ': EMIT
  DUP2 ;print JSR2
  LF

  ( setup reading from file )
  .File/name DEO2
  #0001 .File/length DEO2

  ;read-numbers JSR2

  ;dump-numbers JSR2

  ;compute-stats JSR2

  BRK !

@result-txt "e*g= 00

@read-numbers
  #0000 .n STZ2

  &read-line

    LIT '- EMIT SP

    #00 .i STZ

    &next-digit

      ;read-byte JSR2 ( digit )

      DUP #00 EQU ;&lines-done JCN2
      DUP #30 LTH ;&line-done JCN2

      #30 SUB #00 SWP ( 00 bit )

      ;numbers .n LDZ2 2** ADD2 STH2k ( numbers[n]* : numbers[n]* )
      LDA2 2** ADD2 STH2r STA2 ( )

      .i LDZ INC .i STZ
      ,&next-digit JMP

    &line-done

    POP

    .i LDZ .bit-count STZ

    .n LDZ2 INC2  DUP2 .n STZ2 .line-count STZ2

    SP LIT '/' EMIT SP .line-count LDZ2 DBGSHORTDECn POP2 LF

    ;&read-line JMP2

  &lines-done

  POP

  LIT '* EMIT LIT '=' EMIT SP .line-count LDZ2 DBGSHORTDECn POP2
  LIT 'x EMIT #00 .bit-count LDZ DBGSHORTDECn POP2
  LF
  RTN

@dump-numbers
  #0000 .n STZ2
  &dump-loop
    ;numbers .n LDZ2 2** ADD2 LDA2 ( number )

    DBGSHORTDEC

    POP2

    .n LDZ2 INC2 DUP2 .n STZ2 ( n+1 )
    .line-count LDZ2 LTH2 ,&dump-loop JCN
  LF
  RTN

@count-bits
  #0000 .n STZ2
  &number-loop
    ;numbers .n LDZ2 2** ADD2 LDA2 ( number )

    DBGSHORTDECn SP

    #00 .i STZ
    &bit-loop
      STH2k 2// STH2r NIP #01 AND ( number>>1 bit )

      DUP #30 ADD EMIT LIT ': EMIT

      #00 SWP ( 00 bit )
      .counts .i LDZ 2* ADD STHk ( 00 bit counts[i]* : counts[i]* )
      LDZ2 ADD2 ( counts[i]+bit : counts[i]* )
      DBGSHORTDECn SP
      STHr STZ2 ( )

      .i LDZ INC DUP .i STZ ( i+1 )
      .bit-count LDZ LTH ,&bit-loop JCN
    LF
    POP2
    .n LDZ2 INC2 DUP2 .n STZ2 ( n+1 )
    .line-count LDZ2 LTH2 ,&number-loop JCN
  LF
  RTN

@compute-stats
  ;count-bits JSR2

  LIT 'h EMIT LIT '= EMIT
  .line-count LDZ2 2// DBGSHORTDEC .half-count STZ2

  .bit-count LDZ .i STZ
  &stats-loop
    ( decrement i )
    .i LDZ DEC .i STZ

    .counts .i LDZ 2* ADD LDZ2 ( counts[i] )

    DBGSHORTDECn LIT ': EMIT

    ( update gamma )
    DUP2 .half-count LDZ2 LTH2 NOT ( gamma-digit )

    DUP #30 ADD EMIT

    ( add to gamma )
    #00 SWP .gamma LDZ2 2** ADD2 .gamma STZ2

    ( update epsilon )
    .half-count LDZ2 GTH2 NOT ( epsilon-digit )

    LIT ', EMIT
    DUP #30 ADD EMIT SP

    ( add to epsilon )
    #00 SWP .epsilon LDZ2 2** ADD2 .epsilon STZ2

    ( loop if i != 0 )
    .i LDZ ,&stats-loop JCN

    LF

  LIT 'g EMIT LIT '= EMIT .gamma LDZ2 DBGSHORTDECn POP2 LF
  LIT 'e EMIT LIT '= EMIT .epsilon LDZ2 DBGSHORTDECn POP2 LF

  .gamma LDZ2 SWP .gamma64 STZ2
  .epsilon LDZ2 SWP .epsilon64 STZ2

  ;result-txt ;print JSR2
  ;gamma64 ;epsilon64 ;mul64 JSR2
  ;result64 ;mul64/get-lo JSR2
  ;result64 ;print64 JSR2 LF
  RTN

( -- next-byte )
@read-byte
  #00 ;&byte STA ( clear byte so that EOF reads as zero )
  ;&byte .File/read DEO2
  LIT &byte 00 ( <- this byte is patched by the two previous instructions! )
  JMP2r

~library/console.lib.tal
~library/math.tal

@numbers $2000
