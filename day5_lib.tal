( get-byte list* -- max )
@parse-line
  ;&list STA2
  ( patch call site )
  ;&get-byte STA2

  #0000 ,&max STR2

  #00 ,&started STR
  LIT2r 0000 ( : num )
  &next-byte
    LIT2 [ &get-byte $2 ] JSR2 ( b )
    DUP #0a EQU ,&done JCN
    DUP #00 EQU ,&done JCN
    DUP #30 LTH ,&next-number JCN
    DUP #39 GTH ,&next-number JCN

    #01 ,&started STR
    ( b : num )
    #30 SUB
    ( digit-val : num )
    LIT2r 000a MUL2r ( digit-val : num*10 )
    LITr 00 STH ADD2r
    ,&next-byte JMP

    &next-number
    POP
    STH2r ,&append_if_started JSR
    #00 ,&started STR
    LIT2r 0000 ( : num )
    ,&next-byte JMP

  &done
  POP
  ( append final number )
  STH2r ,&append_if_started JSR
  ( append terminator )
  #ffff ,&list LDR2 STA2
  ,&max LDR2
  RTN

  [ &list $2 &started $1 &max $2 ]

  ( num -- )
  &append_if_started
    ,&started LDR ,&append JCN
    POP2
    RTN

  ( num -- )
  &append
    DUP2 ,&max LDR2 ( num num max )
    LEQ2 ,&not-new-max JCN
      DUP2 ,&max STR2
    &not-new-max
    ,&list LDR2 STA2
    ,&list LDR2 INC2 INC2 ,&list STR2
    RTN

( list -- )
@dump-short-list
  &loop
    DUP2 LDA2
    DUP2 #ffff EQU2 ,&done JCN
    ;print-short-decimal JSR2 SP
    INC2 INC2
    ,&loop JMP
  &done
  POP2 POP2
  LF
  RTN

( get-byte list* -- )
@parse-lines
  STH2 ( : list* )
  ( patch call site )
  ;&get-byte STA2

  #0000 ,&max STR2

  &loop
    ( clear terminator )
    #0000 STH2rk STA2
    LIT2 [ &get-byte $2 ] STH2rk ;parse-line JSR2
    ( line-max )

    DUP2 ,&max LDR2 ( line-max line-max max )
    LEQ2 ,&not-new-max JCN
      DUP2 ,&max STR2
    &not-new-max
    POP2

    ( check for empty list )
    #ffff STH2rk LDA2 EQU2 ,&done JCN
    ( advance pointer )
    LIT2r 0008 ADD2r
    ,&loop JMP
  &done
  POP2r
  ,&max LDR2
  RTN
  [ &max $2 ]

( row* count -- )
@init-row
  STH2 ( row* : count )
  ( clear row )
  &loop
    #0000 OVR2 STA2
    ( advance pointer )
    #0002 ADD2
    ( row* : count )
    DEC2r STH2rk #0000 NEQ2 ,&loop JCN
  POP2r
  ( write terminator )
  #ffff SWP2 STA2
  RTN

( row* rownum lines* -- )
@draw-into-row
  &next-line
    DUP2 LDA2 ( x1 )
    #ffff EQU2 ;&lines-done JCN2

    ( row* rownum lines* )

    ( check for horizontal )
    DUP2 #0002 ADD2 LDA2 ( y1 )
    OVR2 #0006 ADD2 LDA2 ( y1 y2 )
    NEQ2 ;&non-horizontal JCN2

    DUP6 ;draw-horizontal JSR2
    ;&continue JMP2

    &non-horizontal
    DUP6 ;draw-non-horizontal JSR2

    &continue
    ( row* rownum lines* )
    #0008 ADD2
    ;&next-line JMP2
  &lines-done
  ( row* rownum lines* )
  POP2 POP2 POP2
  RTN

( row* rownum line* -- )
@draw-horizontal
  SWP2 [ ,&rownum STR2 ]
  SWP2 [ ,&row STR2 ]
  ( line* )

  DUP2 #0002 ADD2 LDA2 ( line* y1 )
  [ ,&rownum LDR2 ] NEQ2 ;&not-this-row JCN2

  ( line* )
  LDA2k SWP2 ( x1 line* )
  #0004 ADD2 LDA2 ( x1 x2 )

  LTH2k ,&not-x-swapped JCN
    SWP2
  &not-x-swapped
  ( x1 x2 )
  2** [ ,&row LDR2 ] ADD2 STH2 ( x1 : row+x2* )
  2** [ ,&row LDR2 ] ADD2 ( row+x1* : row+x2* )
  &x-loop
    ( row+x* : row+x2* )
    LDA2k INC2 ( row+x* v+1 : row+x2* )
    OVR2 STA2  ( row+x* : row+x2* )
    ( advance x )
    INC2 INC2
    ( loop if x<=x2 )
    DUP2 STH2rk LEQ2 ,&x-loop JCN
  POP2 POP2r
  RTN

  &not-this-row
  ( line* )
  POP2
  RTN
  [ &row $2 &rownum $2 ]

( row* rownum line* -- )
@draw-non-horizontal
  SWP2 [ ;&rownum STA2 ]
  SWP2 [ ;&row STA2 ]

  ( line* )
  STH2 ( : line* )
  STH2rk #0002 ADD2 LDA2 ( y1 )
  STH2rk #0006 ADD2 LDA2 ( y1 y2 )
  STH2rk #0000 ADD2 LDA2 ( y1 y2 x1 : line* )
  STH2rk #0004 ADD2 LDA2 ( y1 y2 x1 x2 : line* )
  POP2r ( y1 y2 x1 x2 )

  LTH2k ,&not-x-swapped JCN
    [ ;&x1 STA2 ]
    [ ;&x2 STA2 ]
    [ ;&y1 STA2 ]
    [ ;&y2 STA2 ]
    ,&start-diagonal JMP
  &not-x-swapped
    [ ;&x2 STA2 ]
    [ ;&x1 STA2 ]
    [ ;&y2 STA2 ]
    [ ;&y1 STA2 ]

  &start-diagonal

  ( test slope )

  [ ,&y2 LDR2 ] [ ,&y1 LDR2 ] GTH2 ;&y-increases JCN2
    ( y decreases )
    [ ,&y1 LDR2 ] [ ,&rownum LDR2 ] LTH2 ;&exit JCN2
    [ ,&y2 LDR2 ] [ ,&rownum LDR2 ] GTH2 ;&exit JCN2

    ( y1 >= rownum >= y2 )
    [ ,&y1 LDR2 ] [ ,&rownum LDR2 ] SUB2 ( distance=y1-rownum )

    ,&apply JMP

  &y-increases
    ( y increases )
    [ ,&y1 LDR2 ] [ ,&rownum LDR2 ] GTH2 ,&exit JCN
    [ ,&y2 LDR2 ] [ ,&rownum LDR2 ] LTH2 ,&exit JCN

    ( y1 <= rownum <= y2 )
    [ ,&rownum LDR2 ] [ ,&y1 LDR2 ] SUB2 ( distance=rownum-y1 )

  &apply

    [ ,&x1 LDR2 ] [ ,&x2 LDR2 ] NEQ2 ,&keep-distance JCN
      ( line is vertical: set distance to zero )
      POP2 #0000
    &keep-distance
    [ ,&x1 LDR2 ] ADD2 ( x1+distance )
    2** [ ,&row LDR2 ] ADD2 ( row[x1+distance]* )
    LDA2k INC2 SWP2 STA2

  &exit
    RTN

  [ &row $2 &rownum $2 &x1 $2 &y1 $2 &x2 $2 &y2 $2 ]


( row* -- count )
@count-crossings
  LIT2r 0000 ( row* : count )
  &loop
    DUP2 LDA2 ( row* num : count )
    DUP2 #ffff EQU2 ,&done JCN

    ( row* num : count )
    #0001 LEQ2 ,&not-crossing JCN
      INC2r
    &not-crossing

    INC2 INC2
    ,&loop JMP
  &done
  ( row* terminator : count )
  POP2 POP2
  STH2r
  RTN

( row* -- )
@dump-row
  &loop
    DUP2 LDA2
    DUP2 #ffff EQU2 ,&done JCN
    DUP2 #0000 NEQ2 ,&not-zero JCN
      POP2 LIT '. EMIT
      ,&continue JMP
    &not-zero
      ;print-short-decimal JSR2
    &continue
    INC2 INC2
    ,&loop JMP
  &done
  POP2 POP2
  LF
  RTN

( lines* max -- count )
@eval-rows
  INC2 ,&size STR2
  LIT2r 0000 ( lines* : rownum )
  #0000 ,&result STR2
  &row-loop
    ( lines* : rownum )
    ;&row [ ,&size LDR2 ] ;init-row JSR2

    DUP2 ;&row STH2rk ( lines* lines* row* rownum )
    ROT2 ( lines* row* rownum lines* )
    ;draw-into-row JSR2

    ;&row ;dump-row JSR2

    ;&row ;count-crossings JSR2
    ,&result LDR2 ADD2 ,&result STR2

    INC2r ( lines* : rownum+1 )
    STH2rk [ ,&size LDR2 ] LTH2 ,&row-loop JCN

  POP2r
  POP2

  ,&result LDR2
  RTN
  [ &size $2 &result $2 &row $1002 ]

~library/console.lib.tal
~library/string.tal
~library/math.tal
